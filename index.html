<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CLIMB THE WORLD! 1.1</title>

    <style>
        /* --- MENÜ STÍLUSOK (KÓD 1) --- */
        :root {
            --neon: #00ff88;
            --glass: rgba(0, 255, 136, 0.12);
            --overlay: rgba(0, 0, 0, 0.55);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Segoe UI", Arial, sans-serif;
        }

        body {
            height: 100vh;
            background: url("https://cdn.pixabay.com/photo/2025/03/24/20/08/climber-9491285_1280.png") center center / cover no-repeat;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: "";
            position: absolute;
            inset: 0;
            background: var(--overlay);
            backdrop-filter: blur(3px);
            z-index: 0;
        }

        .menu {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 50px 60px;
            background: rgba(0,0,0,0.35);
            border: 1px solid var(--neon);
            backdrop-filter: blur(12px);
            animation: fadeIn 1s ease forwards;
            box-shadow: 0 0 25px rgba(0,255,136,0.2);
        }

        .title {
            color: var(--neon);
            font-size: 42px;
            letter-spacing: 4px;
            text-align: center;
            text-shadow: 0 0 15px var(--neon);
            margin-bottom: 20px;
        }

        button {
            padding: 15px 50px;
            font-size: 18px;
            color: var(--neon);
            background: var(--glass);
            border: 2px solid var(--neon);
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(6px);
        }

        button:hover {
            background: rgba(0,255,136,0.3);
            box-shadow: 0 0 20px var(--neon);
            transform: scale(1.05);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .fadeOut {
            animation: fadeOut 0.6s ease forwards;
        }

        @keyframes fadeOut {
            to { opacity: 0; transform: scale(0.9); }
        }

        .git-logo {
            position: absolute;
            bottom: 15px;
            right: 15px;
            width: 37.8px;
            height: 37.8px;
            opacity: 0.8;
            transition: opacity 0.3s ease, transform 0.3s ease;
            cursor: pointer;
        }

        .git-logo:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        /* --- JÁTÉK UI STÍLUSOK (KÓD 2) --- */
        #ui { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            color: white; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5); 
            pointer-events: none; 
            z-index: 5;
            display: none; /* Alapértelmezettként rejtve a játék indulásáig */
        }
        .stats-container { background: rgba(0, 0, 0, 0.4); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.2); }
        .stamina-label { font-weight: bold; letter-spacing: 1px; color: #00ffcc; }
        .stamina-bar { width: 200px; height: 10px; background: #333; border-radius: 5px; margin-top: 5px; overflow: hidden; }
        #stamina-fill { width: 100%; height: 100%; background: #00ffcc; transition: width 0.1s; box-shadow: 0 0 10px #00ffcc; }
        #msg { color: #fff; font-size: 1.1em; margin-top: 10px; font-weight: bold; text-transform: uppercase; }
        .hint { font-size: 0.75em; color: #eee; margin-top: 8px; line-height: 1.4; }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
    </style>
</head>

<body>

    <!-- Audio elements for background music -->
    <audio id="gameMusic" loop>
        <source src="MUSIC.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <audio id="waterMusic" loop>
        <source src="WATER.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <audio id="rainSound" loop>
        <source src="RAIN.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <audio id="snowSound" loop>
        <source src="SNOW.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <div class="menu" id="menu">
        <div class="title">CLIMB THE WORLD!</div>
        <button onclick="startGame()">JÁTÉK INDÍTÁSA</button>
        <button onclick="showInfo()">SÚGÓ</button>
        <button onclick="showInfo2()">1.1 ÚJDONSÁGOK</button>
        <a href="https://github.com" target="_blank" title="Visit GitHub">
            <img src="GIT.png" alt="GitHub" class="git-logo">
        </a>
    </div>

    <div id="ui">
        <div class="stats-container">
            <div class="stamina-label">Energia</div>
            <div class="stamina-bar"><div id="stamina-fill"></div></div>
            <div id="msg">Keresd meg a Titán csúcsot!</div>
            <div class="hint">
                <b>NYILAK</b>: Mozgás<br>
                <b>SPACE GOMB</b>: Mászás<br>
                <b>CTRL GOMB</b>: Sprintelés
            </div>
        </div>
    </div>

    <script>
        const gameMusic = document.getElementById('gameMusic');
        const waterMusic = document.getElementById('waterMusic');

        function startGame() {
            console.log("start");
            
            // Play music in loop
            gameMusic.currentTime = 0;
            gameMusic.volume = 1.0;
            gameMusic.play().catch(error => {
                console.warn("Audio playback failed:", error);
            });

            const menu = document.getElementById("menu");
            menu.classList.add("fadeOut");

            setTimeout(() => {
                menu.style.display = "none";
                document.getElementById("ui").style.display = "block";
            }, 600);
        }

        function showInfo2() {
            alert("Az 1.1-es frissítésben a játékhoz eső, eső hangeffektek, hó, hó hangeffektek lettek hozzáadva. Továbbá a játék saját háttérzenét kapott. A pixabay zene/hangtárából származnak az új zenék/hangok.");
        }

        function showInfo() {
            alert("Keresd meg a Titán csúcsot, mássz fel oda, a zászlóig! Sok sikert kíván a BXcode!");
        }
    </script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- AUDIO MANAGEMENT ---
        const gameMusic = document.getElementById('gameMusic');
        const waterMusic = document.getElementById('waterMusic');
        const rainSound = document.getElementById('rainSound');
        const snowSound = document.getElementById('snowSound');

        let waterAudioState = { isPlaying: false, isFading: false, targetVolume: 0 };
        const WATER_DETECTION_RANGE = 45;
        const WATER_FADE_SPEED = 0.02;

        function updateWaterAudio(playerX, playerZ) {
            const distanceToWater = Math.abs(playerZ + 40);
            const isNearWater = distanceToWater < WATER_DETECTION_RANGE;

            if (isNearWater && !waterAudioState.isPlaying) {
                waterAudioState.isPlaying = true;
                waterAudioState.targetVolume = 0.7;
                waterMusic.currentTime = 0;
                waterMusic.volume = 0;
                waterMusic.play().catch(error => {
                    console.warn("Water audio playback failed:", error);
                });
            } else if (!isNearWater && waterAudioState.isPlaying) {
                waterAudioState.targetVolume = 0;
            }

            if (Math.abs(waterMusic.volume - waterAudioState.targetVolume) > 0.01) {
                if (waterMusic.volume < waterAudioState.targetVolume) {
                    waterMusic.volume = Math.min(waterMusic.volume + WATER_FADE_SPEED, waterAudioState.targetVolume);
                } else {
                    waterMusic.volume = Math.max(waterMusic.volume - WATER_FADE_SPEED, waterAudioState.targetVolume);
                }
            } else {
                waterMusic.volume = waterAudioState.targetVolume;
            }

            if (waterMusic.volume === 0 && waterAudioState.isPlaying && waterAudioState.targetVolume === 0) {
                waterMusic.pause();
                waterAudioState.isPlaying = false;
            }

            const waterIntensity = Math.max(0, 1 - (distanceToWater / WATER_DETECTION_RANGE));
            const targetMainVolume = 1.0 - (waterIntensity * 0.3);
            gameMusic.volume = Math.max(0, Math.min(1, gameMusic.volume + (targetMainVolume - gameMusic.volume) * 0.05));
        }

        // --- WEATHER SYSTEM ---
        const WEATHER_TYPES = { CLEAR: 0, RAIN: 1, SNOW: 2 };
        const WEATHER_CHANCES = { CLEAR: 0.7, RAIN: 0.2, SNOW: 0.1 };

        let currentWeather = WEATHER_TYPES.CLEAR;
        let weatherParticles = [];

        function selectRandomWeather() {
            const rand = Math.random();
            if (rand < WEATHER_CHANCES.CLEAR) return WEATHER_TYPES.CLEAR;
            if (rand < WEATHER_CHANCES.CLEAR + WEATHER_CHANCES.RAIN) return WEATHER_TYPES.RAIN;
            return WEATHER_TYPES.SNOW;
        }

        function playWeatherSound(weatherType) {
            if (weatherType === WEATHER_TYPES.RAIN) {
                rainSound.currentTime = 0;
                rainSound.volume = 0.4;
                rainSound.play().catch(error => console.warn("Rain sound failed:", error));
            } else if (weatherType === WEATHER_TYPES.SNOW) {
                snowSound.currentTime = 0;
                snowSound.volume = 0.2;
                snowSound.play().catch(error => console.warn("Snow sound failed:", error));
            } else {
                rainSound.pause();
                snowSound.pause();
            }
        }

        function stopWeatherSound() {
            rainSound.pause();
            snowSound.pause();
        }

        function changeWeather(scene) {
            // Remove old particles
            weatherParticles.forEach(p => scene.remove(p));
            weatherParticles = [];

            currentWeather = selectRandomWeather();

            if (currentWeather === WEATHER_TYPES.RAIN) {
                createRain(scene);
                playWeatherSound(WEATHER_TYPES.RAIN);
            } else if (currentWeather === WEATHER_TYPES.SNOW) {
                createSnow(scene);
                playWeatherSound(WEATHER_TYPES.SNOW);
            } else {
                stopWeatherSound();
            }
        }

        function createRain(scene) {
            const rainGeometry = new THREE.BufferGeometry();
            const rainCount = 2000;
            const positionArray = new Float32Array(rainCount * 3);

            for (let i = 0; i < rainCount * 3; i += 3) {
                positionArray[i] = (Math.random() - 0.5) * 400;
                positionArray[i + 1] = Math.random() * 200;
                positionArray[i + 2] = (Math.random() - 0.5) * 400;
            }

            rainGeometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
            const rainMaterial = new THREE.PointsMaterial({
                color: 0x4488ff,
                size: 1.2,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });

            const rainParticles = new THREE.Points(rainGeometry, rainMaterial);
            scene.add(rainParticles);
            weatherParticles.push(rainParticles);

            // Store rain data for animation
            rainParticles.userData = {
                velocities: new Float32Array(rainCount * 3),
                type: 'rain'
            };

            const velocities = rainParticles.userData.velocities;
            for (let i = 0; i < rainCount * 3; i += 3) {
                velocities[i] = (Math.random() - 0.5) * 0.5;
                velocities[i + 1] = -Math.random() * 1.5 - 1;
                velocities[i + 2] = (Math.random() - 0.5) * 0.5;
            }
        }

        function createSnow(scene) {
            const snowGeometry = new THREE.BufferGeometry();
            const snowCount = 1500;
            const positionArray = new Float32Array(snowCount * 3);

            for (let i = 0; i < snowCount * 3; i += 3) {
                positionArray[i] = (Math.random() - 0.5) * 400;
                positionArray[i + 1] = Math.random() * 200;
                positionArray[i + 2] = (Math.random() - 0.5) * 400;
            }

            snowGeometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
            const snowMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2.1,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true
            });

            const snowParticles = new THREE.Points(snowGeometry, snowMaterial);
            scene.add(snowParticles);
            weatherParticles.push(snowParticles);

            // Store snow data for animation
            snowParticles.userData = {
                velocities: new Float32Array(snowCount * 3),
                type: 'snow'
            };

            const velocities = snowParticles.userData.velocities;
            for (let i = 0; i < snowCount * 3; i += 3) {
                velocities[i] = (Math.random() - 0.5) * 0.3;
                velocities[i + 1] = -Math.random() * 0.3 - 0.2;
                velocities[i + 2] = (Math.random() - 0.5) * 0.3;
            }
        }

        function updateWeatherParticles() {
            weatherParticles.forEach(particles => {
                const positions = particles.geometry.attributes.position.array;
                const velocities = particles.userData.velocities;

                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += velocities[i];
                    positions[i + 1] += velocities[i + 1];
                    positions[i + 2] += velocities[i + 2];

                    // Respawn particles that are too low
                    if (positions[i + 1] < -10) {
                        positions[i + 1] = 200 + Math.random() * 50;
                    }

                    // Wrap around X and Z
                    if (positions[i] > 200) positions[i] = -200;
                    if (positions[i] < -200) positions[i] = 200;
                    if (positions[i + 2] > 200) positions[i + 2] = -200;
                    if (positions[i + 2] < -200) positions[i + 2] = 200;
                }

                particles.geometry.attributes.position.needsUpdate = true;
            });
        }

        // --- ENGINE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.012);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- DAY/NIGHT SETUP ---
        const cycleDuration = 300000; 
        const dayColor = new THREE.Color(0x87CEEB);
        const sunsetColor = new THREE.Color(0xff7e40);
        const nightColor = new THREE.Color(0x020617);
        const skyColor = new THREE.Color(0x87CEEB);
        scene.background = skyColor;

        // --- LIGHTING ---
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        scene.add(sun);

        // --- WORLD GROUND ---
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(2000, 2000),
            new THREE.MeshStandardMaterial({ color: 0x3d5a35, roughness: 0.8 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- RIVER ---
        const riverGeo = new THREE.PlaneGeometry(2000, 20);
        const riverMat = new THREE.MeshStandardMaterial({ 
            color: 0x0044ff, 
            transparent: true, 
            opacity: 0.6, 
            roughness: 0.1,
            metalness: 0.5 
        });
        const river = new THREE.Mesh(riverGeo, riverMat);
        river.rotation.x = -Math.PI / 2;
        river.position.y = 0.15;
        river.position.z = -40;
        scene.add(river);

        // --- BRIDGES ---
        const bridges = [];
        function createBridge(x, z) {
            const bridgeGroup = new THREE.Group();
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x4d3227, roughness: 0.9 });
            
            const floor = new THREE.Mesh(new THREE.BoxGeometry(10, 0.5, 22), woodMat);
            floor.receiveShadow = true;
            bridgeGroup.add(floor);

            const railGeo = new THREE.BoxGeometry(0.4, 2, 22);
            const lRail = new THREE.Mesh(railGeo, woodMat);
            lRail.position.set(-4.8, 1, 0);
            const rRail = new THREE.Mesh(railGeo, woodMat);
            rRail.position.set(4.8, 1, 0);
            bridgeGroup.add(lRail, rRail);

            bridgeGroup.position.set(x, 0.4, z);
            scene.add(bridgeGroup);
            bridges.push({ x, z, width: 10, length: 22 });
        }

        createBridge(0, -40);
        createBridge(180, -40);
        createBridge(-180, -40);

        // --- MOUNTAINS ---
        const mountains = [];
        function createMountain(x, z, height, radius) {
            const mtnGroup = new THREE.Group();
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x5a5a5a, flatShading: true, roughness: 0.9 });
            const snowMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
            
            const base = new THREE.Mesh(new THREE.ConeGeometry(radius, height, 12), rockMat);
            base.castShadow = true;
            base.receiveShadow = true;
            mtnGroup.add(base);

            const snow = new THREE.Mesh(new THREE.ConeGeometry(radius * 0.45, height * 0.45, 12), snowMat);
            snow.position.y = height * 0.3;
            mtnGroup.add(snow);

            mtnGroup.position.set(x, height / 2, z);
            scene.add(mtnGroup);
            
            return { group: mtnGroup, x, z, height, radius, isTitan: false };
        }

        const mData = [];
        mData.push(createMountain(30, -100, 40, 20));
        mData.push(createMountain(100, -150, 110, 45)); 
        mData.push(createMountain(-90, -90, 55, 25));

        for (let i = 0; i < 15; i++) {
            const mx = (Math.random() - 0.5) * 600;
            const mz = (Math.random() - 0.5) * 500 - 150;
            if (Math.abs(mz + 40) > 30) {
                const mHeight = 40 + Math.random() * 70;
                const mRadius = mHeight * (0.4 + Math.random() * 0.3);
                mData.push(createMountain(mx, mz, mHeight, mRadius));
            }
        }

        const titanIndex = Math.floor(Math.random() * mData.length);
        const titanMtn = mData[titanIndex];
        titanMtn.isTitan = true;

        const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 4), new THREE.MeshStandardMaterial({color:0x222}));
        const flag = new THREE.Mesh(new THREE.BoxGeometry(2, 1.2, 0.1), new THREE.MeshStandardMaterial({color:0xffd700, emissive: 0xaa6600}));
        flag.position.set(1, 1.5, 0);
        pole.add(flag);
        pole.position.y = titanMtn.height / 2 + 1;
        titanMtn.group.add(pole);

        mountains.push(...mData);

        // --- TREES ---
        function createTree(x, z) {
            const tree = new THREE.Group();
            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.8, 2.5, 6);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3c31 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1.25;
            trunk.castShadow = true;
            tree.add(trunk);
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x1e592f, flatShading: true });
            const level1 = new THREE.Mesh(new THREE.ConeGeometry(3, 3.5, 7), leafMat);
            level1.position.y = 3.5;
            level1.castShadow = true;
            tree.add(level1);
            const level2 = new THREE.Mesh(new THREE.ConeGeometry(2.2, 3, 7), leafMat);
            level2.position.y = 5.5;
            level2.castShadow = true;
            tree.add(level2);
            tree.position.set(x, 0, z);
            const scale = 0.8 + Math.random() * 0.5;
            tree.scale.set(scale, scale, scale);
            scene.add(tree);
        }

        for(let i = 0; i < 2000; i++) {
            const range = 700; 
            const tx = (Math.random() - 0.5) * range;
            const tz = (Math.random() - 0.5) * range;
            let hitBlocked = false;
            if (Math.abs(tz + 40) < 15) hitBlocked = true;
            mountains.forEach(m => {
                const dx = tx - m.x; const dz = tz - m.z;
                if(Math.sqrt(dx*dx + dz*dz) < m.radius + 5) hitBlocked = true;
            });
            if(!hitBlocked) createTree(tx, tz);
        }

        // --- MUSHROOMS ---
        function createMushroom(x, z) {
            const mushroom = new THREE.Group();
            const stemGeo = new THREE.CylinderGeometry(0.15, 0.2, 0.8, 6);
            const stemMat = new THREE.MeshStandardMaterial({ color: 0xf5deb3 });
            const stem = new THREE.Mesh(stemGeo, stemMat);
            stem.position.y = 0.4;
            stem.castShadow = true;
            mushroom.add(stem);

            const capGeo = new THREE.SphereGeometry(0.35, 8, 6);
            const capMat = new THREE.MeshStandardMaterial({ color: 0xd32f2f });
            const cap = new THREE.Mesh(capGeo, capMat);
            cap.position.y = 1.0;
            cap.scale.y = 0.6;
            cap.castShadow = true;
            mushroom.add(cap);

            // White spots
            const spotMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            for (let i = 0; i < 5; i++) {
                const spotGeo = new THREE.SphereGeometry(0.08, 6, 6);
                const spot = new THREE.Mesh(spotGeo, spotMat);
                const angle = (i / 5) * Math.PI * 2;
                spot.position.set(Math.cos(angle) * 0.2, 1.15, Math.sin(angle) * 0.2);
                mushroom.add(spot);
            }

            mushroom.position.set(x, 0, z);
            scene.add(mushroom);
        }

        for(let i = 0; i < 150; i++) {
            const range = 700;
            const mx = (Math.random() - 0.5) * range;
            const mz = (Math.random() - 0.5) * range;
            let hitBlocked = false;
            if (Math.abs(mz + 40) < 15) hitBlocked = true;
            mountains.forEach(m => {
                const dx = mx - m.x; const dz = mz - m.z;
                if(Math.sqrt(dx*dx + dz*dz) < m.radius + 5) hitBlocked = true;
            });
            if(!hitBlocked) createMushroom(mx, mz);
        }

        // --- FALLEN TRUNKS ---
        function createFallenTrunk(x, z) {
            const trunk = new THREE.Group();
            const trunkGeo = new THREE.CylinderGeometry(0.4, 0.45, 6, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x6b4423, roughness: 0.95 });
            const trunkMesh = new THREE.Mesh(trunkGeo, trunkMat);
            trunkMesh.castShadow = true;
            trunkMesh.receiveShadow = true;
            trunk.add(trunkMesh);

            // Random rotation
            trunk.rotation.z = Math.random() * Math.PI;
            trunk.rotation.x = (Math.random() - 0.5) * 0.5;
            trunk.position.set(x, 0.5, z);
            scene.add(trunk);
        }

        for(let i = 0; i < 80; i++) {
            const range = 700;
            const fx = (Math.random() - 0.5) * range;
            const fz = (Math.random() - 0.5) * range;
            let hitBlocked = false;
            if (Math.abs(fz + 40) < 15) hitBlocked = true;
            mountains.forEach(m => {
                const dx = fx - m.x; const dz = fz - m.z;
                if(Math.sqrt(dx*dx + dz*dz) < m.radius + 5) hitBlocked = true;
            });
            if(!hitBlocked) createFallenTrunk(fx, fz);
        }

        // --- CHARACTER MODEL ---
        const player = new THREE.Group();
        const characterModel = new THREE.Group();
        player.add(characterModel);
        const matJacket = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.6 });
        const matAccent = new THREE.MeshStandardMaterial({ color: 0x00ffcc, emissive: 0x003333 });
        const matSkin = new THREE.MeshStandardMaterial({ color: 0xffdbac });
        const matHelmet = new THREE.MeshStandardMaterial({ color: 0xff5500 });
        const torso = new THREE.Mesh(new THREE.CapsuleGeometry(0.32, 0.75, 6, 16), matJacket);
        torso.castShadow = true;
        characterModel.add(torso);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 20, 20), matSkin);
        head.position.y = 0.75;
        const helmet = new THREE.Mesh(new THREE.SphereGeometry(0.28, 20, 20, 0, Math.PI * 2, 0, Math.PI / 2), matHelmet);
        helmet.position.y = 0.88;
        const lamp = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.08, 0.1), new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0xffffaa, emissiveIntensity: 1.5 }));
        lamp.position.set(0, 0.85, -0.22);
        characterModel.add(head, helmet, lamp);
        const headlampLight = new THREE.PointLight(0xffffaa, 0, 20);
        headlampLight.position.set(0, 0.85, -0.5);
        player.add(headlampLight);

        function createProLimb(x, y, isArm = true) {
            const group = new THREE.Group();
            const upper = new THREE.Mesh(new THREE.CapsuleGeometry(0.09, 0.38, 4, 10), matJacket);
            upper.position.y = -0.18;
            const joint = new THREE.Group();
            joint.position.y = -0.32;
            const lower = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 0.38, 4, 10), matJacket);
            lower.position.y = -0.18;
            joint.add(lower); upper.add(joint); group.add(upper);
            group.position.set(x, y, 0); characterModel.add(group);
            return { group, joint };
        }
        const lArm = createProLimb(-0.42, 0.4, true); const rArm = createProLimb(0.42, 0.4, true);
        const lLeg = createProLimb(-0.2, -0.38, false); const rLeg = createProLimb(0.2, -0.38, false);

        player.position.set(0, 1.25, 20);
        scene.add(player);

        // --- CONTROLS & PHYSICS ---
        const keys = {};
        window.onkeydown = (e) => keys[e.code] = true;
        window.onkeyup = (e) => keys[e.code] = false;
        let stamina = 100; let walkTime = 0; let win = false; let winTriggered = false;
        const staminaFill = document.getElementById('stamina-fill');

        // Initialize weather
        let weatherChangeTimer = 0;
        const WEATHER_CHANGE_INTERVAL = 15000; // Change weather every 15 seconds
        changeWeather(scene);

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now();
            const cycleProgress = (time % cycleDuration) / cycleDuration;
            const angle = cycleProgress * Math.PI * 2;
            const sunHeight = Math.sin(angle);
            sun.position.set(Math.cos(angle) * 100, sunHeight * 100, Math.cos(angle) * 50);
            const dayIntensity = Math.max(0, sunHeight);
            sun.intensity = dayIntensity * 1.2;
            ambient.intensity = 0.2 + dayIntensity * 0.4;

            if (sunHeight > 0.1) skyColor.lerpColors(sunsetColor, dayColor, (sunHeight - 0.1) / 0.9);
            else if (sunHeight > -0.1) skyColor.lerpColors(nightColor, sunsetColor, (sunHeight + 0.1) / 0.2);
            else skyColor.copy(nightColor);
            scene.background = skyColor; scene.fog.color.copy(skyColor);
            headlampLight.intensity = sunHeight < 0.1 ? 1.5 : 0;
            lamp.material.emissiveIntensity = sunHeight < 0.1 ? 3 : 0.5;
            
            let onBridge = false;
            bridges.forEach(b => {
                if (Math.abs(player.position.x - b.x) < b.width/2 && Math.abs(player.position.z - b.z) < b.length/2) {
                    onBridge = true;
                }
            });
            const inWater = !onBridge && Math.abs(player.position.z + 40) < 10;

            // Update water audio
            updateWaterAudio(player.position.x, player.position.z);

            // Update weather particles
            updateWeatherParticles();

            // Change weather periodically
            weatherChangeTimer += 16;
            if (weatherChangeTimer >= WEATHER_CHANGE_INTERVAL) {
                weatherChangeTimer = 0;
                changeWeather(scene);
            }

            const isSprinting = (keys['ControlLeft'] || keys['ControlRight']) && stamina > 2;
            let moveSpeed = isSprinting ? 0.4 : 0.18;
            if (inWater) moveSpeed *= 0.35; 

            const rotSpeed = 0.06;
            let moving = false, climbing = false;
            let isFalling = false;

            if (!win) {
                if (keys['ArrowLeft']) player.rotation.y += rotSpeed;
                if (keys['ArrowRight']) player.rotation.y -= rotSpeed;
                if (keys['ArrowUp']) { player.translateZ(-moveSpeed); moving = true; }
                if (keys['ArrowDown']) { player.translateZ(moveSpeed); moving = true; }
                if (isSprinting && moving) stamina -= 0.05; 
            }

            let contact = false;
            mountains.forEach(m => {
                const dx = player.position.x - m.x, dz = player.position.z - m.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                const wallBuffer = 1.35;
                const slopeRadius = m.radius * (1 - (player.position.y / m.height)) + wallBuffer;

                if (dist < slopeRadius) {
                    contact = true;
                    const angle = Math.atan2(dz, dx);
                    player.position.x = m.x + Math.cos(angle) * slopeRadius;
                    player.position.z = m.z + Math.sin(angle) * slopeRadius;
                    
                    if (m.isTitan && player.position.y > m.height - 2.5) {
                        win = true;
                        if (!winTriggered) {
                            winTriggered = true;
                            document.getElementById('msg').innerText = "MEGTALÁLTAD ÉS MEGMÁSZTAD A TITÁNT!";
                            document.getElementById('msg').style.color = "gold";
                            setTimeout(() => location.reload(), 4000);
                        }
                    }
                }
            });

            const floorLevel = onBridge ? 2.1 : 1.25;

            if (keys['Space'] && contact && stamina > 0 && !win) {
                player.position.y += 0.16; stamina -= 0.15; climbing = true;
                isFalling = false;
            } else if (player.position.y > floorLevel) {
                player.position.y -= 0.35;
                isFalling = true;
            } else {
                player.position.y = floorLevel; 
                if (stamina < 100) stamina += 1.0; 
                isFalling = false;
            }

            if (isFalling) {
                const panic = Math.sin(time * 0.02) * 0.3;
                lArm.group.rotation.x = -Math.PI * 0.85 + panic; 
                rArm.group.rotation.x = -Math.PI * 0.85 - panic;
                lLeg.group.rotation.x = panic * 0.5;
                rLeg.group.rotation.x = -panic * 0.5;
            } else {
                const speedFact = isSprinting ? 2.5 : (inWater ? 0.8 : 1.2);
                walkTime += (climbing || moving) ? 0.2 * speedFact : 0;
                const swing = Math.sin(walkTime);
                lArm.group.rotation.x = moving ? swing * 0.8 : 0.2;
                rArm.group.rotation.x = moving ? -swing * 0.8 : 0.2;
                lLeg.group.rotation.x = moving ? -swing * 1.0 : 0;
                rLeg.group.rotation.x = moving ? swing * 1.0 : 0;
            }

            staminaFill.style.width = `${Math.max(0, stamina)}%`;
            const camTarget = new THREE.Vector3(0, 6, 12).applyMatrix4(player.matrixWorld);
            camera.position.lerp(camTarget, 0.08);
            camera.lookAt(player.position.x, player.position.y + 2, player.position.z);
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
