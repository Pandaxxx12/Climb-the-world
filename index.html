<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CLIMB THE WORLD! 1.2</title>

    <style>
        /* --- MENÜ STÍLUSOK (KÓD 1) --- */
        :root {
            --neon: #00ff88;
            --glass: rgba(0, 255, 136, 0.12);
            --overlay: rgba(0, 0, 0, 0.55);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Segoe UI", Arial, sans-serif;
        }

        body {
            height: 100vh;
            background: url("https://cdn.pixabay.com/photo/2025/03/24/20/08/climber-9491285_1280.png") center center / cover no-repeat;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: "";
            position: absolute;
            inset: 0;
            background: var(--overlay);
            backdrop-filter: blur(3px);
            z-index: 0;
        }

        .menu {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 50px 60px;
            background: rgba(0,0,0,0.35);
            border: 1px solid var(--neon);
            backdrop-filter: blur(12px);
            animation: fadeIn 1s ease forwards;
            box-shadow: 0 0 25px rgba(0,255,136,0.2);
        }

        .title {
            color: var(--neon);
            font-size: 42px;
            letter-spacing: 4px;
            text-align: center;
            text-shadow: 0 0 15px var(--neon);
            margin-bottom: 20px;
        }

        button {
            padding: 15px 50px;
            font-size: 18px;
            color: var(--neon);
            background: var(--glass);
            border: 2px solid var(--neon);
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(6px);
        }

        button:hover {
            background: rgba(0,255,136,0.3);
            box-shadow: 0 0 20px var(--neon);
            transform: scale(1.05);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .fadeOut {
            animation: fadeOut 0.6s ease forwards;
        }

        @keyframes fadeOut {
            to { opacity: 0; transform: scale(0.9); }
        }

        .git-logo {
            position: absolute;
            bottom: 15px;
            right: 15px;
            width: 37.8px;
            height: 37.8px;
            opacity: 0.8;
            transition: opacity 0.3s ease, transform 0.3s ease;
            cursor: pointer;
        }

        .git-logo:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        /* --- JÁTÉK UI STÍLUSOK (KÓD 2) --- */
        #ui { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            color: white; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5); 
            pointer-events: none; 
            z-index: 5;
            display: none;
        }
        .stats-container { background: rgba(0, 0, 0, 0.4); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.2); }
        .stamina-label { font-weight: bold; letter-spacing: 1px; color: #00ffcc; }
        .stamina-bar { width: 200px; height: 10px; background: #333; border-radius: 5px; margin-top: 5px; overflow: hidden; }
        #stamina-fill { width: 100%; height: 100%; background: #00ffcc; transition: width 0.1s; box-shadow: 0 0 10px #00ffcc; }
        #msg { color: #fff; font-size: 1.1em; margin-top: 10px; font-weight: bold; text-transform: uppercase; }
        .hint { font-size: 0.75em; color: #eee; margin-top: 8px; line-height: 1.4; }

        /* --- SKIN MENU STYLES --- */
        #skinMenu {
            display: none;
            position: absolute;
            top: 50px;
            right: 50px;
            z-index: 99;
            background: rgba(18, 18, 18, 0.95);
            border: 2px solid #00ff88;
            padding: 24px 36px;
            border-radius: 16px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
            backdrop-filter: blur(12px);
        }

        #skinMenu .skin-title {
            color: #00ff88;
            font-size: 24px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .skin-btn {
            display: block;
            width: 160px;
            margin-bottom: 12px;
            padding: 12px 20px;
            color: #fff;
            border: 2px solid #00ff88;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 8px;
            text-transform: uppercase;
        }

        .skin-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.6);
        }

        .skin-btn[data-skin="red"] { background: #d32f2f; }
        .skin-btn[data-skin="black"] { background: #1a1a1a; }
        .skin-btn[data-skin="blue"] { background: #296bd6; }
        .skin-btn[data-skin="yellow"] { background: #FFD600; color: #000; }

        .close-menu-hint {
            color: #888;
            font-size: 0.75em;
            margin-top: 15px;
            text-align: center;
        }

        /* --- CUSTOM ALERT SYSTEM STYLES --- */
        .alert-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: overlayFadeIn 0.3s ease forwards;
        }

        @keyframes overlayFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .alert-box {
            background: rgba(18, 18, 18, 0.98);
            border: 2px solid var(--neon);
            border-radius: 20px;
            padding: 40px 50px;
            max-width: 600px;
            width: 90%;
            box-shadow: 
                0 0 30px rgba(0, 255, 136, 0.4),
                0 0 60px rgba(0, 255, 136, 0.2),
                inset 0 0 20px rgba(0, 255, 136, 0.1);
            backdrop-filter: blur(12px);
            animation: alertSlideIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            pointer-events: auto;
        }

        @keyframes alertSlideIn {
            from {
                opacity: 0;
                transform: scale(0.8) translateY(-50px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .alert-title {
            color: var(--neon);
            font-size: 32px;
            font-weight: bold;
            letter-spacing: 3px;
            text-align: center;
            text-shadow: 0 0 15px var(--neon);
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        .alert-content {
            color: #e0e0e0;
            font-size: 16px;
            line-height: 1.8;
            text-align: center;
            margin-bottom: 30px;
            letter-spacing: 0.5px;
        }

        .alert-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .alert-btn {
            padding: 12px 35px;
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 1px;
            color: var(--neon);
            background: var(--glass);
            border: 2px solid var(--neon);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(6px);
            text-transform: uppercase;
            min-width: 120px;
        }

        .alert-btn:hover {
            background: rgba(0, 255, 136, 0.25);
            box-shadow: 0 0 20px var(--neon), inset 0 0 10px rgba(0, 255, 136, 0.2);
            transform: scale(1.08);
        }

        .alert-btn:active {
            transform: scale(0.95);
        }

        .alert-btn.alert-btn-primary {
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }

        .alert-btn-close {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid var(--neon);
            border-radius: 50%;
            color: var(--neon);
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            padding: 0;
        }

        .alert-btn-close:hover {
            background: rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 20px var(--neon);
            transform: rotate(90deg);
        }

        .alert-overlay.closing {
            animation: overlayFadeOut 0.3s ease forwards;
        }

        .alert-box.closing {
            animation: alertSlideOut 0.3s ease forwards;
        }

        @keyframes overlayFadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        @keyframes alertSlideOut {
            from {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
            to {
                opacity: 0;
                transform: scale(0.8) translateY(50px);
            }
        }

        .alert-divider {
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--neon), transparent);
            margin: 20px 0;
            opacity: 0.5;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
    </style>
</head>

<body>

    <!-- Audio elements for background music -->
    <audio id="gameMusic" loop>
        <source src="MUSIC.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <audio id="waterMusic" loop>
        <source src="WATER.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <audio id="rainSound" loop>
        <source src="RAIN.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <audio id="snowSound" loop>
        <source src="SNOW.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <div class="menu" id="menu">
        <div class="title">CLIMB THE WORLD!</div>
        <button onclick="startGame()">JÁTÉK INDÍTÁSA</button>
        <button onclick="showCustomAlert('SÚGÓ', 'Keresd meg a Titán csúcsot, mássz fel a zászlóig! Az irányító gombok listája ott van, oldalt az egész játék alatt. Sok sikert kíván a BXcode!')">SÚGÓ</button>
        <button onclick="showCustomAlert('1.2 ÚJDONSÁGOK', 'Az 1.2-es frissítésben a projekt GitHub linkje lett hozzáadva a játékmenü sarkába. A hó és az eső textúrája javítva lett. A legnagyobb újdonságként a játékba kerültek a különböző skinek, és automatikusan felvesz a karakter esőkabátot az esőben. A skineket az S gombbal lehet változtatni.')">1.2 ÚJDONSÁGOK</button>
        <a href="https://github.com/Pandaxxx12/Climb-the-world" target="_blank" title="Github">
            <img src="GIT.png" alt="GitHub" class="git-logo">
        </a>
    </div>

    <div id="ui">
        <div class="stats-container">
            <div class="stamina-label">Energia</div>
            <div class="stamina-bar"><div id="stamina-fill"></div></div>
            <div id="msg">Keresd meg a Titán csúcsot!</div>
            <div class="hint">
                <b>NYILAK</b>: Mozgás<br>
                <b>SPACE GOMB</b>: Mászás<br>
                <b>CTRL GOMB</b>: Sprintelés<br>
                <b>S GOMB</b>: Skin választó
            </div>
        </div>
    </div>

    <!-- SKIN MENU -->
    <div id="skinMenu">
        <div class="skin-title">SKINEK</div>
        <button class="skin-btn" data-skin="red">PIROS</button>
        <button class="skin-btn" data-skin="black">FEKETE</button>
        <button class="skin-btn" data-skin="blue">KÉK</button>
        <button class="skin-btn" data-skin="yellow">SÁRGA ESŐKABÁT</button>
        <div class="close-menu-hint">Nyomj ESC-t a menü bezárásához</div>
    </div>

    <script>
        const gameMusic = document.getElementById('gameMusic');
        const waterMusic = document.getElementById('waterMusic');

        // --- CUSTOM ALERT SYSTEM ---
        function showCustomAlert(title, content, buttons = null) {
            const overlay = document.createElement('div');
            overlay.className = 'alert-overlay';

            const alertBox = document.createElement('div');
            alertBox.className = 'alert-box';
            alertBox.style.position = 'relative';

            const closeBtn = document.createElement('button');
            closeBtn.className = 'alert-btn-close';
            closeBtn.innerHTML = '✕';
            closeBtn.onclick = () => closeAlert(overlay, alertBox);

            const titleEl = document.createElement('div');
            titleEl.className = 'alert-title';
            titleEl.textContent = title;

            const contentEl = document.createElement('div');
            contentEl.className = 'alert-content';
            contentEl.textContent = content;

            const divider = document.createElement('div');
            divider.className = 'alert-divider';

            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'alert-buttons';

            // Default button if none provided
            if (!buttons || buttons.length === 0) {
                const btn = document.createElement('button');
                btn.className = 'alert-btn alert-btn-primary';
                btn.textContent = 'OK';
                btn.onclick = () => closeAlert(overlay, alertBox);
                buttonsContainer.appendChild(btn);
            } else {
                buttons.forEach(buttonConfig => {
                    const btn = document.createElement('button');
                    btn.className = `alert-btn ${buttonConfig.primary ? 'alert-btn-primary' : ''}`;
                    btn.textContent = buttonConfig.text;
                    btn.onclick = () => {
                        if (buttonConfig.callback) buttonConfig.callback();
                        closeAlert(overlay, alertBox);
                    };
                    buttonsContainer.appendChild(btn);
                });
            }

            alertBox.appendChild(closeBtn);
            alertBox.appendChild(titleEl);
            alertBox.appendChild(divider);
            alertBox.appendChild(contentEl);
            alertBox.appendChild(buttonsContainer);
            overlay.appendChild(alertBox);
            document.body.appendChild(overlay);

            overlay.onclick = (e) => {
                if (e.target === overlay) closeAlert(overlay, alertBox);
            };

            // Prevent body scroll when alert is open
            document.body.style.overflow = 'hidden';
        }

        function closeAlert(overlay, alertBox) {
            overlay.classList.add('closing');
            alertBox.classList.add('closing');
            setTimeout(() => {
                overlay.remove();
                document.body.style.overflow = '';
            }, 300);
        }

        function startGame() {
            console.log("start");
            
            gameMusic.currentTime = 0;
            gameMusic.volume = 1.0;
            gameMusic.play().catch(error => {
                console.warn("Audio playback failed:", error);
            });

            const menu = document.getElementById("menu");
            menu.classList.add("fadeOut");

            setTimeout(() => {
                menu.style.display = "none";
                document.getElementById("ui").style.display = "block";
            }, 600);
        }

        // --- OLD ALERT REPLACEMENTS (REMOVED) ---
        // showInfo() and showInfo2() have been replaced with showCustomAlert calls in buttons
    </script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- AUDIO MANAGEMENT ---
        const gameMusic = document.getElementById('gameMusic');
        const waterMusic = document.getElementById('waterMusic');
        const rainSound = document.getElementById('rainSound');
        const snowSound = document.getElementById('snowSound');

        let waterAudioState = { isPlaying: false, isFading: false, targetVolume: 0 };
        const WATER_DETECTION_RANGE = 45;
        const WATER_FADE_SPEED = 0.02;

        function updateWaterAudio(playerX, playerZ) {
            const distanceToWater = Math.abs(playerZ + 40);
            const isNearWater = distanceToWater < WATER_DETECTION_RANGE;

            if (isNearWater && !waterAudioState.isPlaying) {
                waterAudioState.isPlaying = true;
                waterAudioState.targetVolume = 0.7;
                waterMusic.currentTime = 0;
                waterMusic.volume = 0;
                waterMusic.play().catch(error => {
                    console.warn("Water audio playback failed:", error);
                });
            } else if (!isNearWater && waterAudioState.isPlaying) {
                waterAudioState.targetVolume = 0;
            }

            if (Math.abs(waterMusic.volume - waterAudioState.targetVolume) > 0.01) {
                if (waterMusic.volume < waterAudioState.targetVolume) {
                    waterMusic.volume = Math.min(waterMusic.volume + WATER_FADE_SPEED, waterAudioState.targetVolume);
                } else {
                    waterMusic.volume = Math.max(waterMusic.volume - WATER_FADE_SPEED, waterAudioState.targetVolume);
                }
            } else {
                waterMusic.volume = waterAudioState.targetVolume;
            }

            if (waterMusic.volume === 0 && waterAudioState.isPlaying && waterAudioState.targetVolume === 0) {
                waterMusic.pause();
                waterAudioState.isPlaying = false;
            }

            const waterIntensity = Math.max(0, 1 - (distanceToWater / WATER_DETECTION_RANGE));
            const targetMainVolume = 1.0 - (waterIntensity * 0.3);
            gameMusic.volume = Math.max(0, Math.min(1, gameMusic.volume + (targetMainVolume - gameMusic.volume) * 0.05));
        }

        // --- CHARACTER SKINS ---
        const SKINS = {
            red:    { color: 0xd32f2f, name: "Red" },
            black:  { color: 0x1a1a1a, name: "Black" },
            blue:   { color: 0x296bd6, name: "Blue" },
            yellow: { color: 0xFFD600, name: "Yellow Raincoat" }
        };
        let currentSkin = "black";
        let lastCustomSkin = "black";
        let skinMenuVisible = false;
        let isWearingRaincoat = false;

        // --- WEATHER SYSTEM ---
        const WEATHER_TYPES = { CLEAR: 0, RAIN: 1, SNOW: 2 };
        const WEATHER_CHANCES = { CLEAR: 0.7, RAIN: 0.2, SNOW: 0.1 };

        let currentWeather = WEATHER_TYPES.CLEAR;
        let weatherParticles = [];

        function selectRandomWeather() {
            const rand = Math.random();
            if (rand < WEATHER_CHANCES.CLEAR) return WEATHER_TYPES.CLEAR;
            if (rand < WEATHER_CHANCES.CLEAR + WEATHER_CHANCES.RAIN) return WEATHER_TYPES.RAIN;
            return WEATHER_TYPES.SNOW;
        }

        function playWeatherSound(weatherType) {
            if (weatherType === WEATHER_TYPES.RAIN) {
                rainSound.currentTime = 0;
                rainSound.volume = 0.4;
                rainSound.play().catch(error => console.warn("Rain sound failed:", error));
            } else if (weatherType === WEATHER_TYPES.SNOW) {
                snowSound.currentTime = 0;
                snowSound.volume = 0.2;
                snowSound.play().catch(error => console.warn("Snow sound failed:", error));
            } else {
                rainSound.pause();
                snowSound.pause();
            }
        }

        function stopWeatherSound() {
            rainSound.pause();
            snowSound.pause();
        }

        // Create raindrop texture - circular droplets
        function createRaindropTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');

            // Draw a soft circular raindrop
            const gradient = ctx.createRadialGradient(16, 10, 0, 16, 16, 14);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.5, 'rgba(200, 220, 255, 0.8)');
            gradient.addColorStop(1, 'rgba(100, 150, 200, 0.3)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(16, 16, 12, 0, Math.PI * 2);
            ctx.fill();

            // Add a highlight for realism
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(12, 10, 4, 0, Math.PI * 2);
            ctx.fill();

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function createRain(scene) {
            const rainGeometry = new THREE.BufferGeometry();
            const rainCount = 2000;
            const positionArray = new Float32Array(rainCount * 3);

            for (let i = 0; i < rainCount * 3; i += 3) {
                positionArray[i] = (Math.random() - 0.5) * 400;
                positionArray[i + 1] = Math.random() * 200;
                positionArray[i + 2] = (Math.random() - 0.5) * 400;
            }

            rainGeometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
            const rainMaterial = new THREE.PointsMaterial({
                color: 0x4488ff,
                size: 2.5,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true,
                map: createRaindropTexture(),
                alphaMap: createRaindropTexture()
            });

            const rainParticles = new THREE.Points(rainGeometry, rainMaterial);
            scene.add(rainParticles);
            weatherParticles.push(rainParticles);

            rainParticles.userData = {
                velocities: new Float32Array(rainCount * 3),
                type: 'rain'
            };

            const velocities = rainParticles.userData.velocities;
            for (let i = 0; i < rainCount * 3; i += 3) {
                velocities[i] = (Math.random() - 0.5) * 0.5;
                velocities[i + 1] = -Math.random() * 1.5 - 1;
                velocities[i + 2] = (Math.random() - 0.5) * 0.5;
            }
        }

        function createSnow(scene) {
            const snowGeometry = new THREE.BufferGeometry();
            const snowCount = 1200;
            const positionArray = new Float32Array(snowCount * 3);
            const sizeArray = new Float32Array(snowCount);

            for (let i = 0; i < snowCount * 3; i += 3) {
                positionArray[i] = (Math.random() - 0.5) * 400;
                positionArray[i + 1] = Math.random() * 200;
                positionArray[i + 2] = (Math.random() - 0.5) * 400;
            }

            for (let i = 0; i < snowCount; i++) {
                sizeArray[i] = Math.random() * 3.5 + 1.5;
            }

            snowGeometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
            snowGeometry.setAttribute('size', new THREE.BufferAttribute(sizeArray, 1));

            const snowMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 3,
                transparent: true,
                opacity: 0.85,
                sizeAttenuation: true,
                sizeVariation: true,
                map: createSnowflakeTexture(),
                alphaMap: createSnowflakeTexture()
            });

            const snowParticles = new THREE.Points(snowGeometry, snowMaterial);
            scene.add(snowParticles);
            weatherParticles.push(snowParticles);

            snowParticles.userData = {
                velocities: new Float32Array(snowCount * 3),
                sizes: sizeArray,
                type: 'snow',
                wobbleOffsets: new Float32Array(snowCount)
            };

            const velocities = snowParticles.userData.velocities;
            const wobbleOffsets = snowParticles.userData.wobbleOffsets;
            
            for (let i = 0; i < snowCount * 3; i += 3) {
                const index = Math.floor(i / 3);
                velocities[i] = (Math.random() - 0.5) * 0.25;
                velocities[i + 1] = -Math.random() * 0.4 - 0.15;
                velocities[i + 2] = (Math.random() - 0.5) * 0.25;
                wobbleOffsets[index] = Math.random() * Math.PI * 2;
            }
        }

        function createSnowflakeTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(16, 16, 12, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = 16 + Math.cos(angle) * 10;
                const y = 16 + Math.sin(angle) * 10;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function updateWeatherParticles() {
            weatherParticles.forEach(particles => {
                const positions = particles.geometry.attributes.position.array;
                const velocities = particles.userData.velocities;
                const time = Date.now() * 0.001;

                if (particles.userData.type === 'snow') {
                    const wobbleOffsets = particles.userData.wobbleOffsets;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        const index = i / 3;
                        const wobbleX = Math.sin(time * 0.5 + wobbleOffsets[index]) * 0.15;
                        const wobbleZ = Math.cos(time * 0.3 + wobbleOffsets[index]) * 0.12;
                        
                        positions[i] += velocities[i] + wobbleX;
                        positions[i + 1] += velocities[i + 1];
                        positions[i + 2] += velocities[i + 2] + wobbleZ;

                        if (positions[i + 1] < -10) {
                            positions[i + 1] = 220 + Math.random() * 30;
                        }

                        if (positions[i] > 250) positions[i] = -250;
                        if (positions[i] < -250) positions[i] = 250;
                        if (positions[i + 2] > 250) positions[i + 2] = -250;
                        if (positions[i + 2] < -250) positions[i + 2] = 250;
                    }
                } else {
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] += velocities[i];
                        positions[i + 1] += velocities[i + 1];
                        positions[i + 2] += velocities[i + 2];

                        if (positions[i + 1] < -10) {
                            positions[i + 1] = 200 + Math.random() * 50;
                        }

                        if (positions[i] > 200) positions[i] = -200;
                        if (positions[i] < -200) positions[i] = 200;
                        if (positions[i + 2] > 200) positions[i + 2] = -200;
                        if (positions[i + 2] < -200) positions[i + 2] = 200;
                    }
                }

                particles.geometry.attributes.position.needsUpdate = true;
            });
        }

        // --- ENGINE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.012);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- DAY/NIGHT SETUP ---
        const cycleDuration = 300000; 
        const dayColor = new THREE.Color(0x87CEEB);
        const sunsetColor = new THREE.Color(0xff7e40);
        const nightColor = new THREE.Color(0x020617);
        const skyColor = new THREE.Color(0x87CEEB);
        scene.background = skyColor;

        // --- LIGHTING ---
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        scene.add(sun);

        // --- WORLD GROUND ---
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(2000, 2000),
            new THREE.MeshStandardMaterial({ color: 0x3d5a35, roughness: 0.8 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- RIVER ---
        const riverGeo = new THREE.PlaneGeometry(2000, 20);
        const riverMat = new THREE.MeshStandardMaterial({ 
            color: 0x0044ff, 
            transparent: true, 
            opacity: 0.6, 
            roughness: 0.1,
            metalness: 0.5 
        });
        const river = new THREE.Mesh(riverGeo, riverMat);
        river.rotation.x = -Math.PI / 2;
        river.position.y = 0.15;
        river.position.z = -40;
        scene.add(river);

        // --- BRIDGES ---
        const bridges = [];
        function createBridge(x, z) {
            const bridgeGroup = new THREE.Group();
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x4d3227, roughness: 0.9 });
            
            const floor = new THREE.Mesh(new THREE.BoxGeometry(10, 0.5, 22), woodMat);
            floor.receiveShadow = true;
            bridgeGroup.add(floor);

            const railGeo = new THREE.BoxGeometry(0.4, 2, 22);
            const lRail = new THREE.Mesh(railGeo, woodMat);
            lRail.position.set(-4.8, 1, 0);
            const rRail = new THREE.Mesh(railGeo, woodMat);
            rRail.position.set(4.8, 1, 0);
            bridgeGroup.add(lRail, rRail);

            bridgeGroup.position.set(x, 0.4, z);
            scene.add(bridgeGroup);
            bridges.push({ x, z, width: 10, length: 22 });
        }

        createBridge(0, -40);
        createBridge(180, -40);
        createBridge(-180, -40);

        // --- MOUNTAINS ---
        const mountains = [];
        function createMountain(x, z, height, radius) {
            const mtnGroup = new THREE.Group();
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x5a5a5a, flatShading: true, roughness: 0.9 });
            const snowMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
            
            const base = new THREE.Mesh(new THREE.ConeGeometry(radius, height, 12), rockMat);
            base.castShadow = true;
            base.receiveShadow = true;
            mtnGroup.add(base);

            const snow = new THREE.Mesh(new THREE.ConeGeometry(radius * 0.45, height * 0.45, 12), snowMat);
            snow.position.y = height * 0.3;
            mtnGroup.add(snow);

            mtnGroup.position.set(x, height / 2, z);
            scene.add(mtnGroup);
            
            return { group: mtnGroup, x, z, height, radius, isTitan: false };
        }

        const mData = [];
        mData.push(createMountain(30, -100, 40, 20));
        mData.push(createMountain(100, -150, 110, 45)); 
        mData.push(createMountain(-90, -90, 55, 25));

        for (let i = 0; i < 15; i++) {
            const mx = (Math.random() - 0.5) * 600;
            const mz = (Math.random() - 0.5) * 500 - 150;
            if (Math.abs(mz + 40) > 30) {
                const mHeight = 40 + Math.random() * 70;
                const mRadius = mHeight * (0.4 + Math.random() * 0.3);
                mData.push(createMountain(mx, mz, mHeight, mRadius));
            }
        }

        const titanIndex = Math.floor(Math.random() * mData.length);
        const titanMtn = mData[titanIndex];
        titanMtn.isTitan = true;

        const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 4), new THREE.MeshStandardMaterial({color:0x222}));
        const flag = new THREE.Mesh(new THREE.BoxGeometry(2, 1.2, 0.1), new THREE.MeshStandardMaterial({color:0xffd700, emissive: 0xaa6600}));
        flag.position.set(1, 1.5, 0);
        pole.add(flag);
        pole.position.y = titanMtn.height / 2 + 1;
        titanMtn.group.add(pole);

        mountains.push(...mData);

        // --- TREES ---
        function createTree(x, z) {
            const tree = new THREE.Group();
            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.8, 2.5, 6);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3c31 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1.25;
            trunk.castShadow = true;
            tree.add(trunk);
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x1e592f, flatShading: true });
            const level1 = new THREE.Mesh(new THREE.ConeGeometry(3, 3.5, 7), leafMat);
            level1.position.y = 3.5;
            level1.castShadow = true;
            tree.add(level1);
            const level2 = new THREE.Mesh(new THREE.ConeGeometry(2.2, 3, 7), leafMat);
            level2.position.y = 5.5;
            level2.castShadow = true;
            tree.add(level2);
            tree.position.set(x, 0, z);
            const scale = 0.8 + Math.random() * 0.5;
            tree.scale.set(scale, scale, scale);
            scene.add(tree);
        }

        for(let i = 0; i < 2000; i++) {
            const range = 700; 
            const tx = (Math.random() - 0.5) * range;
            const tz = (Math.random() - 0.5) * range;
            let hitBlocked = false;
            if (Math.abs(tz + 40) < 15) hitBlocked = true;
            mountains.forEach(m => {
                const dx = tx - m.x; const dz = tz - m.z;
                if(Math.sqrt(dx*dx + dz*dz) < m.radius + 5) hitBlocked = true;
            });
            if(!hitBlocked) createTree(tx, tz);
        }

        // --- MUSHROOMS ---
        function createMushroom(x, z) {
            const mushroom = new THREE.Group();
            const stemGeo = new THREE.CylinderGeometry(0.15, 0.2, 0.8, 6);
            const stemMat = new THREE.MeshStandardMaterial({ color: 0xf5deb3 });
            const stem = new THREE.Mesh(stemGeo, stemMat);
            stem.position.y = 0.4;
            stem.castShadow = true;
            mushroom.add(stem);

            const capGeo = new THREE.SphereGeometry(0.35, 8, 6);
            const capMat = new THREE.MeshStandardMaterial({ color: 0xd32f2f });
            const cap = new THREE.Mesh(capGeo, capMat);
            cap.position.y = 1.0;
            cap.scale.y = 0.6;
            cap.castShadow = true;
            mushroom.add(cap);

            const spotMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            for (let i = 0; i < 5; i++) {
                const spotGeo = new THREE.SphereGeometry(0.08, 6, 6);
                const spot = new THREE.Mesh(spotGeo, spotMat);
                const angle = (i / 5) * Math.PI * 2;
                spot.position.set(Math.cos(angle) * 0.2, 1.15, Math.sin(angle) * 0.2);
                mushroom.add(spot);
            }

            mushroom.position.set(x, 0, z);
            scene.add(mushroom);
        }

        for(let i = 0; i < 150; i++) {
            const range = 700;
            const mx = (Math.random() - 0.5) * range;
            const mz = (Math.random() - 0.5) * range;
            let hitBlocked = false;
            if (Math.abs(mz + 40) < 15) hitBlocked = true;
            mountains.forEach(m => {
                const dx = mx - m.x; const dz = mz - m.z;
                if(Math.sqrt(dx*dx + dz*dz) < m.radius + 5) hitBlocked = true;
            });
            if(!hitBlocked) createMushroom(mx, mz);
        }

        // --- FALLEN TRUNKS ---
        function createFallenTrunk(x, z) {
            const trunk = new THREE.Group();
            const trunkGeo = new THREE.CylinderGeometry(0.4, 0.45, 6, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x6b4423, roughness: 0.95 });
            const trunkMesh = new THREE.Mesh(trunkGeo, trunkMat);
            trunkMesh.castShadow = true;
            trunkMesh.receiveShadow = true;
            trunk.add(trunkMesh);

            trunk.rotation.z = Math.random() * Math.PI;
            trunk.rotation.x = (Math.random() - 0.5) * 0.5;
            trunk.position.set(x, 0.5, z);
            scene.add(trunk);
        }

        for(let i = 0; i < 80; i++) {
            const range = 700;
            const fx = (Math.random() - 0.5) * range;
            const fz = (Math.random() - 0.5) * range;
            let hitBlocked = false;
            if (Math.abs(fz + 40) < 15) hitBlocked = true;
            mountains.forEach(m => {
                const dx = fx - m.x; const dz = fz - m.z;
                if(Math.sqrt(dx*dx + dz*dz) < m.radius + 5) hitBlocked = true;
            });
            if(!hitBlocked) createFallenTrunk(fx, fz);
        }

        // --- CHARACTER MODEL WITH ENHANCED RAINCOAT ---
        const player = new THREE.Group();
        const characterModel = new THREE.Group();
        player.add(characterModel);
        const matJacket = new THREE.MeshStandardMaterial({ color: SKINS[currentSkin].color, roughness: 0.6 });
        const matRaincoat = new THREE.MeshStandardMaterial({ 
            color: 0xFFD600, 
            roughness: 0.3, 
            metalness: 0.1,
            emissive: 0xccaa00,
            emissiveIntensity: 0.3
        });
        const matAccent = new THREE.MeshStandardMaterial({ color: 0x00ffcc, emissive: 0x003333 });
        const matSkin = new THREE.MeshStandardMaterial({ color: 0xffdbac });
        const matHelmet = new THREE.MeshStandardMaterial({ color: 0xff5500 });
        
        const torso = new THREE.Mesh(new THREE.CapsuleGeometry(0.32, 0.75, 6, 16), matJacket);
        torso.castShadow = true;
        characterModel.add(torso);

        const raincoatHood = new THREE.Group();
        const hoodGeo = new THREE.SphereGeometry(0.32, 20, 10, 0, Math.PI * 2, 0, Math.PI / 2);
        const raincoatMesh = new THREE.Mesh(hoodGeo, matRaincoat);
        raincoatMesh.position.y = 0.75;
        raincoatMesh.scale.y = 0.9;
        raincoatHood.add(raincoatMesh);
        
        const shoulderExt = new THREE.Mesh(
            new THREE.SphereGeometry(0.28, 16, 16),
            matRaincoat
        );
        shoulderExt.position.y = 0.3;
        shoulderExt.scale.set(1.3, 0.6, 1.1);
        raincoatHood.add(shoulderExt);
        characterModel.add(raincoatHood);
        raincoatHood.visible = false;

        const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 20, 20), matSkin);
        head.position.y = 0.75;
        const helmet = new THREE.Mesh(new THREE.SphereGeometry(0.28, 20, 20, 0, Math.PI * 2, 0, Math.PI / 2), matHelmet);
        helmet.position.y = 0.88;
        const lamp = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.08, 0.1), new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0xffffaa, emissiveIntensity: 1.5 }));
        lamp.position.set(0, 0.85, -0.22);
        characterModel.add(head, helmet, lamp);
        const headlampLight = new THREE.PointLight(0xffffaa, 0, 20);
        headlampLight.position.set(0, 0.85, -0.5);
        player.add(headlampLight);

        function createProLimb(x, y, isArm = true) {
            const group = new THREE.Group();
            const upper = new THREE.Mesh(new THREE.CapsuleGeometry(0.09, 0.38, 4, 10), matJacket);
            upper.position.y = -0.18;
            const joint = new THREE.Group();
            joint.position.y = -0.32;
            const lower = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 0.38, 4, 10), matJacket);
            lower.position.y = -0.18;
            joint.add(lower); upper.add(joint); group.add(upper);
            group.position.set(x, y, 0); characterModel.add(group);
            return { group, joint };
        }
        const lArm = createProLimb(-0.42, 0.4, true); 
        const rArm = createProLimb(0.42, 0.4, true);
        const lLeg = createProLimb(-0.2, -0.38, false); 
        const rLeg = createProLimb(0.2, -0.38, false);

        player.position.set(0, 1.25, 20);
        scene.add(player);

        function changeSkin(skinName) {
            currentSkin = skinName;
            if (skinName !== "yellow") {
                lastCustomSkin = skinName;
                matJacket.color.set(SKINS[skinName].color);
                isWearingRaincoat = false;
                raincoatHood.visible = false;
            } else {
                matJacket.color.set(SKINS[skinName].color);
                isWearingRaincoat = true;
                raincoatHood.visible = true;
            }
        }

        // --- CONTROLS & PHYSICS ---
        const keys = {};
        window.onkeydown = (e) => {
            keys[e.code] = true;
            if (e.code === "KeyS" && !skinMenuVisible) {
                skinMenuVisible = true;
                document.getElementById("skinMenu").style.display = "block";
            } else if (e.code === "Escape" && skinMenuVisible) {
                skinMenuVisible = false;
                document.getElementById("skinMenu").style.display = "none";
            }
        };
        window.onkeyup = (e) => keys[e.code] = false;

        document.querySelectorAll("#skinMenu .skin-btn").forEach(btn => {
            btn.addEventListener("click", function() {
                const newSkin = this.getAttribute("data-skin");
                changeSkin(newSkin);
                skinMenuVisible = false;
                document.getElementById("skinMenu").style.display = "none";
            });
        });

        let stamina = 100; let walkTime = 0; let win = false; let winTriggered = false;
        const staminaFill = document.getElementById('stamina-fill');

        let weatherChangeTimer = 0;
        const WEATHER_CHANGE_INTERVAL = 15000;
        changeWeather(scene);

        function changeWeather(scene) {
            weatherParticles.forEach(p => scene.remove(p));
            weatherParticles = [];

            currentWeather = selectRandomWeather();

            if (currentWeather === WEATHER_TYPES.RAIN) {
                createRain(scene);
                changeSkin("yellow");
                document.getElementById("msg").innerText = "Keresd meg a Titán csúcsot!";
                playWeatherSound(WEATHER_TYPES.RAIN);
            } else if (currentWeather === WEATHER_TYPES.SNOW) {
                createSnow(scene);
                changeSkin(lastCustomSkin);
                document.getElementById("msg").innerText = "Keresd meg a Titán csúcsot!";
                playWeatherSound(WEATHER_TYPES.SNOW);
            } else {
                changeSkin(lastCustomSkin);
                document.getElementById("msg").innerText = "Keresd meg a Titán csúcsot!";
                stopWeatherSound();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now();
            const cycleProgress = (time % cycleDuration) / cycleDuration;
            const angle = cycleProgress * Math.PI * 2;
            const sunHeight = Math.sin(angle);
            sun.position.set(Math.cos(angle) * 100, sunHeight * 100, Math.cos(angle) * 50);
            const dayIntensity = Math.max(0, sunHeight);
            sun.intensity = dayIntensity * 1.2;
            ambient.intensity = 0.2 + dayIntensity * 0.4;

            if (sunHeight > 0.1) skyColor.lerpColors(sunsetColor, dayColor, (sunHeight - 0.1) / 0.9);
            else if (sunHeight > -0.1) skyColor.lerpColors(nightColor, sunsetColor, (sunHeight + 0.1) / 0.2);
            else skyColor.copy(nightColor);
            scene.background = skyColor; scene.fog.color.copy(skyColor);
            headlampLight.intensity = sunHeight < 0.1 ? 1.5 : 0;
            lamp.material.emissiveIntensity = sunHeight < 0.1 ? 3 : 0.5;
            
            let onBridge = false;
            bridges.forEach(b => {
                if (Math.abs(player.position.x - b.x) < b.width/2 && Math.abs(player.position.z - b.z) < b.length/2) {
                    onBridge = true;
                }
            });
            const inWater = !onBridge && Math.abs(player.position.z + 40) < 10;

            updateWaterAudio(player.position.x, player.position.z);
            updateWeatherParticles();

            weatherChangeTimer += 16;
            if (weatherChangeTimer >= WEATHER_CHANGE_INTERVAL) {
                weatherChangeTimer = 0;
                changeWeather(scene);
            }

            const isSprinting = (keys['ControlLeft'] || keys['ControlRight']) && stamina > 2;
            let moveSpeed = isSprinting ? 0.4 : 0.18;
            if (inWater) moveSpeed *= 0.35; 

            const rotSpeed = 0.06;
            let moving = false, climbing = false;
            let isFalling = false;

            if (!win) {
                if (keys['ArrowLeft']) player.rotation.y += rotSpeed;
                if (keys['ArrowRight']) player.rotation.y -= rotSpeed;
                if (keys['ArrowUp']) { player.translateZ(-moveSpeed); moving = true; }
                if (keys['ArrowDown']) { player.translateZ(moveSpeed); moving = true; }
                if (isSprinting && moving) stamina -= 0.05; 
            }

            let contact = false;
            mountains.forEach(m => {
                const dx = player.position.x - m.x, dz = player.position.z - m.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                const wallBuffer = 1.35;
                const slopeRadius = m.radius * (1 - (player.position.y / m.height)) + wallBuffer;

                if (dist < slopeRadius) {
                    contact = true;
                    const angle = Math.atan2(dz, dx);
                    player.position.x = m.x + Math.cos(angle) * slopeRadius;
                    player.position.z = m.z + Math.sin(angle) * slopeRadius;
                    
                    if (m.isTitan && player.position.y > m.height - 2.5) {
                        win = true;
                        if (!winTriggered) {
                            winTriggered = true;
                            document.getElementById('msg').innerText = "MEGTALÁLTAD ÉS MEGMÁSZTAD A TITÁNT!";
                            document.getElementById('msg').style.color = "gold";
                            setTimeout(() => location.reload(), 4000);
                        }
                    }
                }
            });

            const floorLevel = onBridge ? 2.1 : 1.25;

            if (keys['Space'] && contact && stamina > 0 && !win) {
                player.position.y += 0.16; stamina -= 0.15; climbing = true;
                isFalling = false;
            } else if (player.position.y > floorLevel) {
                player.position.y -= 0.35;
                isFalling = true;
            } else {
                player.position.y = floorLevel; 
                if (stamina < 100) stamina += 1.0; 
                isFalling = false;
            }

            if (isFalling) {
                const panic = Math.sin(time * 0.02) * 0.3;
                lArm.group.rotation.x = -Math.PI * 0.85 + panic; 
                rArm.group.rotation.x = -Math.PI * 0.85 - panic;
                lLeg.group.rotation.x = panic * 0.5;
                rLeg.group.rotation.x = -panic * 0.5;
            } else {
                const speedFact = isSprinting ? 2.5 : (inWater ? 0.8 : 1.2);
                walkTime += (climbing || moving) ? 0.2 * speedFact : 0;
                const swing = Math.sin(walkTime);
                lArm.group.rotation.x = moving ? swing * 0.8 : 0.2;
                rArm.group.rotation.x = moving ? -swing * 0.8 : 0.2;
                lLeg.group.rotation.x = moving ? -swing * 1.0 : 0;
                rLeg.group.rotation.x = moving ? swing * 1.0 : 0;
            }

            staminaFill.style.width = `${Math.max(0, stamina)}%`;
            const camTarget = new THREE.Vector3(0, 6, 12).applyMatrix4(player.matrixWorld);
            camera.position.lerp(camTarget, 0.08);
            camera.lookAt(player.position.x, player.position.y + 2, player.position.z);
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
